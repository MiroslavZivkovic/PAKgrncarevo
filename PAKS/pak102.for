C=======================================================================
C
C=======================================================================
      SUBROUTINE SOPSVL(A,B,MAXA,W,EIG,Y,IW,
     1                  NW,MAXPRS,NWK,N,LANMAX)
C
C     GLAVNI PROGRAM ZA RE[AVANJE VELIKIH OP[TIH SOPSTVENIH PROBLEMA
C                  - LANCZOS-OV ALGORITAM -
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
CM      COMMON A(10000),B(10000),MAXA(212)
CM      DIMENSION W(6000),IW(100),EIG(100),Y(10000)
C     OTVARANJE DIREKTNE DATOTEKE ZA POTPROGRAM STORE
C     DU@INA SLOGA OMOGU!AVA MEMORISANJE VEKTORA SA 100 ELEMENATA.
C     BEZ FILEDEF-A BROJ SLOGOVA JE 50.
C     ZA DRUGOJA^IJI BROJ SLOGOVA KORISTITI U PROCEDURI FILEDEF SA XTENT
C     FILEDEF FT09F001 DISK DISK09 LAN A A (RECFM F XTENT 100
C
      DIMENSION A(*),B(*),MAXA(*)
      DIMENSION W(*),IW(*),EIG(*),Y(*)
       OPEN(UNIT=29,FILE='I9',ERR=99,ACCESS='DIRECT',RECL=24000)
C     OPEN(UNIT=9,FILE='I9',ERR=99,ACCESS='DIRECT',RECL=8000)
       FREKL=1.D-4
       FREKD=1.D30
       POMER=0.D0
CM      READ(10,19)N,LANMAX,MAXPRS,NW,NWK,FREKL,FREKD,POMER
CM   19 FORMAT(5I5,2F15.0,F15.10)
CM      READ(57,*)(A(I),I=1,NWK)
CM      READ(58,*)(B(I),I=1,NWK)
CM      READ(59,299)(MAXA(I),I=1,N+1)
CM  299 FORMAT(I5)
      IF(DABS(POMER).LT.1.D-10) GO TO 18
      DO 17 I=1,NWK
   17 A(I)=A(I)-B(I)*POMER
   18 ENDL=1.0D0/((2.0D0*4.0D0*DATAN(1.0D0)*FREKL)**2-POMER)
      ENDR=1.0D0/((2.0D0*4.0D0*DATAN(1.0D0)*FREKD)**2-POMER)
      CALL ALDLT(A,MAXA,N)
CM      CALL ALDLT(N)
      DO 10 I=1,NW
10    W(I)=0.
      W(1)=1.
      CALL LANDRVpak(N,LANMAX,MAXPRS,ENDL,ENDR,NW,W,IW,EIG,Y,IERR,NEIG)
      IF (IERR.EQ.0) GO TO 98
      WRITE(3,1)IERR
1     FORMAT(' ','IERR=',I7)
98    WRITE(3,2)NEIG
2     FORMAT(' ','NEIG=',I5)
      DO 70 I=1,NEIG
70    EIG(I)=DSQRT(1.0D0/EIG(I)+POMER)/(2.0D0*4.0D0*DATAN(1.0D0))
      WRITE(3,3)(EIG(I),I=1,NEIG)
3     FORMAT(' ','EIG=',4D15.5)
      K=1
      DO 4 I=1,NEIG
      WRITE(3,7)I
      WRITE(3,5)(Y(J),J=K,K+N-1)
      K=K+N
7     FORMAT(' ',' SOPSTVENI VEKTOR BR.  ', I3)
5     FORMAT(' ',6(1PD13.5))
4     CONTINUE
99    CONTINUE
      STOP
      END
C
      SUBROUTINE LANDRVpak(N,LANMAX,MAXPRS,ENDL,ENDR,NW,W,IW,EIG,Y,
     1                  IERR,NEIG1)
C
C            *****************************************
C            *                                       *
C            *            L  A  N  S  E  L           *
C            *                                       *
C            *         LANCZOS ALGORITHM WITH        *
C            *      SELECTIVE ORTHOGONALIZATION      *
C            *                                       *
C            *          B. N O U R - O M I D         *
C            *                                       *
C            *****************************************
C
C.... INPUTS
C
C     N       DIMENSION OF THE EIGENPROBLEM
C     LANMAX  UPPER LIMIT TO THE NUMBER OF LANCZOS STEPS
C     MAXPRS  UPPER LIMIT TO THE NUMBER OF WANTED EIGENPAIRS
C     ENDL    LEFT END OF THE INTERVAL CONTAINING THE WANTED EIGENVALUES
C     ENDR    RIGHT END OF THE INTERVAL CONTAINING THE WANTED EIGENVALUE
C     NW      LENGTH OF WORK ARRAY W
C     W       WORK ARRAY OF LENGTH NW
C     IW      WORK ARRAY OF LENGTH MAXPRS
C
C.... OUTPUTS
C
C     EIG     ARRAY OF LENGTH MAXPRS TO HOLD THE CONVERGED RITZ VALUES
C     Y       ARRAY OF LENGTH MAXPRS*N TO HOLD THE CONVERGED RITZ VECTOR
C     IERR    ERROR FLAG
C     NEIG    TOTAL NUMBER OF CONVERGED EIGENPAIRS
C
C.... SUBROUTINES: DDOTPAK,GETEPS,LANSEL,OPM,RAN,STPONE
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      include 'paka.inc'
      
      COMMON /REPERI/ LCORD,LID,LMAXA,LMHT
      COMMON /LANCZO/ LA,LB,LTT,LW
      DIMENSION NQ(5),Y(N,1),EIG(*),W(*),IW(*)
C      INTEGER*2 IRAND1,IRAND2
C
C.... COMMON IDATA
C
C     EIGL    INNER MOST EIGENVALUE CONVERGED FROM LEFT END OF
C             TRANSFORMED SPECTRUM
C     EIGR    INNER MOST EIGENVALUE CONVERGED FROM RIGHT END OF
C             TRANSFORMED SPECTRUM
C     NEIG1   TOTAL NUMBER OF CONVERGED EIGENVALUES
C
      COMMON /IDATA/ EIGL,EIGR,NEIG
C
C.... COMMON RDATA
C
C     RNM     NORM OF THE RESIDUAL VECTOR IN R(NQ(1))
C     RNM2    SQUARE OF RNM
C     SPREAD  WIDTH OF THE INTERVAL CONTAINING THE UNCONVERGED
C             EIGENVALUES
C     TOL     TOLERANCE FOR CONVERGENCE OF THE EIGENVALUES
C     EPS     COMPUTER PRECISION
C     EPS1    EPS*DSQRT(N)
C     REPS    SQUARE ROOT OF EPS
C
      COMMON /RDATA/ RNM,RNM2,SPREAD,TOL,EPS,EPS1,REPS
C
      COMMON /LANCON/ ZERO, TENTH, EIGHTH, FOURTH, HALF, ONE, TWO,
     1                FOUR, TEN, ONE28, TWO56, FIVE12, ORTFAC, OVRFLW
C
C.... CHECK INPUT DATA
C
      IERR = 0
      MT = 6*N + 2*MAXPRS + 10*LANMAX
      IF ( N .LE. 0 )           IERR = IERR + 1
      IF ( LANMAX .LE. 0 )      IERR = IERR + 2
      IF ( ENDR .GE. ENDL )     IERR = IERR + 4
      IF ( MAXPRS .LE. 0 )      IERR = IERR + 8
      IF ( MAXPRS .GT. LANMAX ) IERR = IERR + 16
      IF ( LANMAX .GT. N )      IERR = IERR + 32
      IF ( MT .GT. NW )         IERR = IERR + 64
      IF (IERR .GT. 0 ) RETURN
C
C.... COMPUTE THE MACHINE PRECISION
C
      EPS  = GETEPS(IBETA,IT,IRND)
C
      REPS = DSQRT(EPS)
      DFLN=FLOAT(N)
      EPS1 = EPS*DSQRT(DFLN)
C
C.... SET POINTERS AND INITIALIZE
C
      M1 = 1      + 6*N
      M2 = MAXPRS + M1
      M3 = MAXPRS + M2
      M4 = LANMAX + M3
      M5 = LANMAX + M4
      M6 = LANMAX + M5
      M7 = LANMAX + M6
      M8 = LANMAX + M7
      M9 = LANMAX + M8
      M10 = LANMAX + M9
      M11 = LANMAX + M10
C
C.... IF MORE STORAGE IS TO BE ALLOCATED, MUST CHANGE "MT" ABOVE
C
      NS = NW - MT + 2*LANMAX
      NQ(1) = N + 1
      DO 20 I = 2,5
         NQ(I) = NQ(I-1) + N
20    CONTINUE
C
C.... CHECK FOR STARTING VECTOR
C
      RNM2 = ZERO
      DO 30 I = 1,N
         RNM2 = RNM2 + DABS(W(I))
30    CONTINUE
C
C     IF (RNM2 .EQ. ZERO) THEN
      IF (DABS(RNM2-ZERO).LT.1.0D-30) THEN
C
C....    GET RANDOM STARTING VECTOR
C
         IRAND = N + LANMAX + MAXPRS + NW
       IRAND1=IRAND
         DO 40 I = 1,N
          IRAND2=I
C     NAPRAVITI SUBROUTINE RAN KOJA PUTI STARTNI VEKTOR UKOLIKO JE ON 0
C           W(I) = RAN(IRAND1,IRAND2)
40    CONTINUE
      END IF
C
      CALL OPM(A(LB),A(LMAXA),W,W(NQ(3)),N)
      RNM2 = DDOTPAK(N,W,1,W(NQ(3)),1)
      CALL STPONE(N,W(M3),W(M4),W(M5),W(M6),W,NQ)
      CALL LANSELpak(N,LANMAX,MAXPRS,NS,ENDL,ENDR,W,W(M3),W(M4),W(M5),
     1           W(M6),EIG,W(M1),W(M2),W(M10),W(M11),W(M7),W(M8),
     2           IW,Y,W(M9),NQ,IERR)
      IF (IERR.GT.0) THEN
      NEIG1=NEIG
      GO TO 50
      ENDIF
   50 NEIG1 = NEIG
  350 IS=0
      DO 360 I=1,NEIG-1
      IF(EIG(I+1).LT.EIG(I)) GO TO 360
      IS=IS+1
      EIGT=EIG(I+1)
      EIG(I+1)=EIG(I)
      EIG(I)=EIGT
      DO 370 K=1,N
      RT=Y(K,I+1)
      Y(K,I+1)=Y(K,I)
  370 Y(K,I)=RT
  360 CONTINUE
      IF(IS.GT.0) GO TO 350
C
      RETURN
      END
C
      BLOCK DATA
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /LANCON/ ZERO, TENTH, EIGHTH, FOURTH, HALF, ONE, TWO,
     1                FOUR, TEN, ONE28, TWO56, FIVE12, ORTFAC, OVRFLW
      DATA ZERO, TENTH, EIGHTH, FOURTH, HALF, ONE, TWO, FOUR, TEN,
     1     ONE28, TWO56, FIVE12, ORTFAC, OVRFLW /
     2     0.0D0, 0.1D0, 0.125D0, 0.25D0, 0.5D0, 1.0D0, 2.0D0, 4.0D0,
     3     10.0D0, 128.0D0, 256.0D0, 512.0D0, 4.0D0, 1.7014D+38/
      END
C
      FUNCTION GETEPS(IBETA, IT, IRND)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      COMMON /LANCON/ ZERO, TENTH, EIGHTH, FOURTH, HALF, ONE, TWO,
     1                FOUR, TEN, ONE28, TWO56, FIVE12, ORTFAC, OVRFLW
C
C.... DETERMINE IBETA, BETA
C
      A = ONE
10    A = A + A
C     IF (((A + ONE) - A) - ONE .EQ. ZERO) GO TO 10
      IF (DABS(((A + ONE) - A) - ONE - ZERO).LT.1.0D-30) GO TO 10
      B = ONE
20    B = B + B
C     IF ((A + B) - A .EQ. ZERO) GO TO 20
      IF (DABS((A + B) - A - ZERO).LT.1.0D-30) GO TO 20
      IBETA = INT(SNGL((A + B) - A))
      BETA = FLOAT(IBETA)
C
C.... DETERMINE IT,IRND
C
      IT = 0
      B = ONE
30    IT = IT + 1
      B = B * BETA
C     IF (((B + ONE) - B) - ONE .EQ. ZERO) GO TO 30
      IF (DABS(((B + ONE) - B) - ONE - ZERO).LT.1.0D-30) GO TO 30
      IRND = 0
      BETAM1 = BETA - ONE
C     IF ((A + BETAM1) -A .NE. ZERO) IRND = 1
      IF (DABS((A + BETAM1) -A - ZERO).GT.1.0D-30) IRND = 1
C
C.... DETERMINE EPS
C
      BETAIN = ONE / BETA
      A = ONE
      DO 40 I = 1, IT + 3
         A = A * BETAIN
40    CONTINUE
C
C50    IF ((ONE + A) - ONE .NE. ZERO) GO TO 60
50    IF (DABS((ONE + A) - ONE - ZERO).GT.1.0D-30) GO TO 60
      A = A * BETA
      GO TO 50
60    EPS = A
      IF ((IBETA .EQ. 2) .OR.  (IRND .EQ. 0)) GO TO 70
      A = (A*(ONE + A)) / (ONE + ONE)
C     IF ((ONE + A) - ONE .NE. ZERO) EPS = A
      IF (DABS((ONE + A) - ONE - ZERO).GT.1.0D-30) EPS = A
70    GETEPS = EPS
C
      RETURN
      END
C
      SUBROUTINE STPONE(N,ALF,BET,ALPH,BET2,R,NQ)
C
C.... THIS ROUTINE PERFORMS THE FIRST STEP OF LANCZOS ALGORITHM.
C     IT PERFORMS A STEP OF LOCAL REORTHOGONALIZATION IF NEEDED.
C
C.... INPUT/OUTPUT
C
C     N      DIMENSION OF THE EIGENPROBLEM
C     ALF    THE NEW DIAGONAL OF T
C     BET    THE NEW OFF-DIAGONAL OF T
C     ALPH   THE NEW DIAGONAL OF DEFLATED T
C     BET2   THE NEW OFF-DIAGONAL SQUARED OF THE DEFLATED T
C     R      AN ARRAY CONTAINING <R(J),Q(J),Q(J-1),P(J),MR(J)>
C     NQ(5)  LOCATION POINTERS FOR THE ARRAY R
C
C.... SUBROUTINES: DAXPYPAK,DCOPYPAK,DDOTPAK,DSCALPAK,OPK,OPM
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION NQ(5),R(*)
      include 'paka.inc'
      
      COMMON /REPERI/ LCORD,LID,LMAXA,LMHT
      COMMON /LANCZO/ LA,LB,LTT,LW
      COMMON /RDATA/ RNM,RNM2,SPREAD,TOL,EPS,EPS1,REPS
      COMMON /LANCON/ ZERO, TENTH, EIGHTH, FOURTH, HALF, ONE, TWO,
     1                FOUR, TEN, ONE28, TWO56, FIVE12, ORTFAC, OVRFLW
C
C.... MODIFY R TO SATISFY THE CORRECT CONDITIONS FOR SINGULAR M
C
      T = ONE/DSQRT(RNM2)
      CALL DCOPYPAK(N,R(NQ(3)),1,R(NQ(4)),1)
      CALL DSCALPAK(N,T,R(NQ(4)),1)
C
      CALL OPK(A(LA),A(LMAXA),R(NQ(4)),R,N)
      CALL OPM(A(LB),A(LMAXA),R,R(NQ(3)),N)
      RNM2 = DDOTPAK(N,R,1,R(NQ(3)),1)
      RNM = DSQRT(RNM2)
C
C.... BET2(1) OUGHT TO BE ZERO.
C     BET(1) STORES THE M-NORM OF THE STARTING VECTOR.
C
      BET2 = ZERO
      BET = RNM
      T = ONE/RNM
      CALL DCOPYPAK(N,R,1,R(NQ(1)),1)
      CALL DSCALPAK(N,T,R(NQ(1)),1)
      CALL DCOPYPAK(N,R(NQ(3)),1,R(NQ(4)),1)
      CALL DSCALPAK(N,T,R(NQ(4)),1)
      CALL OPK(A(LA),A(LMAXA),R(NQ(4)),R,N)
C
      ALF = ZERO
      DALF = DDOTPAK(N,R,1,R(NQ(4)),1)
      DO 10 I=1,2
      CALL DAXPYPAK(N,-DALF,R(NQ(1)),1,R,1)
      ALF = ALF + DALF
      ALPH = ALF
      CALL OPM(A(LB),A(LMAXA),R,R(NQ(3)),N)
      RNM2 = DDOTPAK(N,R,1,R(NQ(3)),1)
      IF (I .EQ. 2) RETURN
C
      DALF = DDOTPAK(N,R(NQ(1)),1,R(NQ(3)),1)
      DBET = DDOTPAK(N,R(NQ(2)),1,R(NQ(3)),1)
      CALL DAXPYPAK(N,-DBET, R(NQ(2)),1,R,1)
10    CONTINUE
C
      RETURN
      END
C
      SUBROUTINE LANSELpak(N,LANMAX,MAXPRS,NS,ENDL,ENDR,R,ALF,BET,ALPH,
     1                 BET2,EIG,TAU,OLDTAU,RHO,WORK,ETA,OLDETA,INFO,
     2                 Y,S,NQ,IERR)
C
C.... INPUTS
C
C     N       DIMENSION OF THE EIGENPROBLEM
C     LANMAX  UPPER LIMIT TO THE NUMBER OF LANCZOS STEPS
C     MAXPRS  UPPER LIMIT TO THE NUMBER OF WANTED EIGENPAIRS
C     NS      LENGTH OF THE ARRAY S
C     ENDL    LEFT END OF THE INTERVAL CONTAINING THE WANTED EIGENVALUES
C     ENDR    RIGHT END OF THE INTERVAL CONTAINING THE WANTED EIGENVALUE
C
C.... WORK SPACE
C
C     R       HOLDS 6 VECTORS OF LENGTH N. SEE THE TEXT FOR DETAILS.
C     NQ(5)   CONTAINS THE POINTERS TO THE BEGINING OF EACH VECTOR IN R.
C     ALF     ARRAY OF LENGTH LANMAX TO HOLD DIAGONAL OF THE TRIDIAG. T
C     BET     ARRAY OF LENGTH LANMAX TO HOLD OFF-DIAGONAL OF T
C     ALPH    DIAGONAL OF THE DEFLATED TRIDIAGONAL
C     BET2    SQUARE OF THE OFF-DIAGONALSOF THE DEFLATED TRIDIAGONAL
C     TAU     ORTHOGONALITY ESTIMATE OF RITZ VECTORS AT STEP J
C     OLDTAU  ORTHOGONALITY ESTIMATE OF RITZ VECTORS AT STEP J-1
C     RHO     WORKING ARRAY USED IN DEFLAT()
C     ETA     ORTHOGONALITY ESTIMATE OF LANCZOS VECTORS AT STEP J
C     OLDETA  ORTHOGONALITY ESTIMATE OF LANCZOS VECTORS AT STEP J-1
C     INFO    INFORMATION ARRAY ABOUT EIGENVECTORS OF T
C     S       ARRAY FOR COMPUTING THE EIGENVECTORS OF THE TRIDIAGONAL
C     WORK    WORKING ARRAY TO HOLD SQUARES OF ARRAY BETA
C
C.... OUTPUTS
C
C     EIG     ARRAY OF LENGTH MAXPRS TO HOLD THE CONVERGED RITZ VALUES
C     Y       ARRAY OF LENGTH MAXPRS*N TO HOLD THE CONVERGED RITZ VECTOR
C     NEIG    NUMBER OF COMPUTED EIGENPAIRS
C     IERR    ERROR FLAG
C
C.... SUBROUTINES: ANALZT,ENOUGH,LANSIM,ORTBND,PURGE,RITVEC
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION R(*),Y(N,1),EIG(*),TAU(*),OLDTAU(*),ALF(*),BET(*)
      DIMENSION S(*),NQ(5),ALPH(*),BET2(*),ETA(*),OLDETA(*),INFO(*)
      DIMENSION RHO(*),WORK(*)
      LOGICAL ENOUGH
C
      COMMON /RDATA/ RNM,RNM2,SPREAD,TOL,EPS,EPS1,REPS
      COMMON /IDATA/ EIGL,EIGR,NEIG
C
      JJ     = 1
      ETA(1) = EPS1
      EIGL   = ENDL - (ENDR - ENDL)
      EIGR   = ENDR + (ENDR - ENDL)
      NEIG   = 0
C
C.... LANCZOS LOOP
C
      DO 10 J = 2,LANMAX
         NBUF = NS/J
         RNM  = DSQRT(DABS(RNM2))
C
C.... RESTORE THE ORTHOGONALITY STATE WHEN NEEDED
C
      CALL PURGE(R,R(NQ(1)),R(NQ(3)),R(NQ(4)),R(NQ(5)),Y,ALF,BET,S,
     1           EIG,ETA,OLDETA,TAU,OLDTAU,WORK,INFO,N,J-1,NBUF,IERR)
      IF (IERR .GT. 0) RETURN
C
C.... UPDATE THE RITZ VALUES
C
      CALL ANALZT(JJ,ALPH,BET2,EIG,TAU,OLDTAU,RHO,INFO)
C
      IF ( ENOUGH(ENDL,ENDR,MAXPRS) ) GO TO 20
C
      IF (RNM .LT. REPS*SPREAD) GO TO 20
      JJ   = JJ + 1
C
C.... TAKE A LANCZOS STEP
C
      CALL LANSIMpak(R,ALF(J),BET(J),ALPH(JJ),BET2(JJ),RNM,RNM2,NQ,
     1            N,J)
C
C.... UPDATE THE ORTHOGONALITY BOUNDS
C
      CALL ORTBND(ALF,BET,J,EPS1,ETA,OLDETA,TAU,OLDTAU,EIG,INFO,
     1             RNM,NEIG,N)
C
10    CONTINUE
20    J = J -1
C
C.... COMPUTE THE REMAINING RITZ VECTORS
C
      DO 50 I=1,NEIG
         M=1
         DO 40 K = 1,NEIG
            IF ( INFO(K) .GT. 0 ) INFO(K) = -INFO(K)
            M =  MIN(IABS(INFO(K)),M)
40    CONTINUE
C
      IF ( M .EQ. 0 ) THEN
         CALL RITVEC(R,R(NQ(1)),R(NQ(3)),R(NQ(4)),R(NQ(5)),Y,ALF,
     1          BET,EIG,S,INFO,N,J,NEIG,NBUF,.TRUE.,WORK,IERR)
         IF (IERR .GT. 0) THEN
            RETURN
         ENDIF
      ELSE
         GO TO 60
      END IF
C
50    CONTINUE
C
60    CONTINUE
      IF( J .EQ. LANMAX ) THEN
      IERR = -1
      END IF
C
      RETURN
      END
C
      LOGICAL FUNCTION ENOUGH(ENDL,ENDR,MAXPRS)
C
C.... EXAMINE IF ENOUGH EIGENVALUES HAVE CONVERGED
C
C.... INPUT
C
C     ENDL    LEFT END OF THE INTERVAL CONTAINING THE WANTED EIGENVALUES
C     ENDR    RIGHT END OF THE INTERVAL CONTAINING THE WANTED EIGENVAL.
C     MAXPRS  UPPER LIMIT TO THE NUMBER OF WANTED EIGENPAIRS
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (NMAX = 128)
C
      COMMON /ATDATA/ THET(NMAX),BJ(NMAX),WINDOW,NBD(2),NDST
      COMMON/IDATA/EIGL,EIGR,NEIG
C
      ENOUGH = .TRUE.
      IF ( NEIG .GT. MAXPRS ) RETURN
C
      ENOUGH = ( THET(1) .GT. ENDL .AND. THET(NDST) .LT. ENDR ) .AND.
     1          (( EIGL .GT. ENDL .AND. EIGL .LT. ENDR ) .OR.
     2           ( EIGR .GT. ENDL .AND. EIGR .LT. ENDR ))
C
      RETURN
      END
C
      SUBROUTINE LANSIMpak(R,ALF,BET,ALPH,BET2,RNM,RNM2,NQ,N,J)
C
C.... THIS ROUTINE PERFORMS A SINGLE STEP OF THE LANCZOS ALGORITHM,
C     FOLLOWED BY A STEP OF LOCAL REORTHOGONALIZATION IF NEEDED.
C
C.... INPUT/OUTPUT
C
C     R      AN ARRAY CONTAINING <R(J),Q(J),Q(J-1),P(J),MR(J)>
C     ALF    THE NEW DIAGONAL OF T
C     BET    THE NEW OFF-DIAGONAL OF T
C     ALPH   THE NEW DIAGONAL OF DEFLATED T
C     BET2   THE NEW OFF-DIAGONAL SQUARED OF THE DEFLATED T
C     RNM    NORM OF R(J)
C     RNM2   RNM**2
C     NQ(5)  LOCATION POINTERS FOR THE ARRAY R
C     N      DIMENSION OF THE EIGENPROBLEM
C     J      CURRENT LANCZOS STEP
C
C.... SUBROUTINES: DAXPYPAK,DCOPYPAK,DDOTPAK,DSCALPAK,OPK,OPM,STORE
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NQ(5),R(*)
C
      include 'paka.inc'
      
      COMMON /REPERI/ LCORD,LID,LMAXA,LMHT
      COMMON /LANCZO/ LA,LB,LTT,LW
      COMMON /LANCON/ ZERO, TENTH, EIGHTH, FOURTH, HALF, ONE, TWO,
     1                FOUR, TEN, ONE28, TWO56, FIVE12, ORTFAC, OVRFLW
C
C.... SWAP Q(J) AND Q(J-1)
C
      NTMP = NQ(2)
      NQ(2) = NQ(1)
      NQ(1) = NTMP
C
C.... Q = R/BETA
C
      T = ONE/RNM
      CALL DCOPYPAK(N,R,1,R(NQ(1)),1)
      CALL DSCALPAK(N,T,R(NQ(1)),1)
C
C.... P = PBAR/BETA
C
      CALL DCOPYPAK(N,R(NQ(3)),1,R(NQ(4)),1)
      CALL DSCALPAK(N,T,R(NQ(4)),1)
C
C.... R = ( K INVERSE ) * Q
C
      CALL OPK(A(LA),A(LMAXA),R(NQ(4)),R,N)
C
C.... R = R - Q(J-1)*BETA
C
      T = -RNM
      CALL DAXPYPAK(N,T,R(NQ(2)),1,R,1)
C
C.... STORE Q(J-1)
C
      CALL STORE(R(NQ(2)),N,J-1,1)
C
C.... START LOCAL REORTHOGONALIZATION
C
      BET = RNM
      BET2 = RNM2
      ALF = ZERO
C
C.... ALF = ( R TRANSPOSE ) * P
C
      DALF = DDOTPAK(N,R,1,R(NQ(4)),1)
      DO 10 I=1,2
         CALL DAXPYPAK(N,-DALF,R(NQ(1)),1,R,1)
         ALF = ALF + DALF
         CALL OPM(A(LB),A(LMAXA),R,R(NQ(3)),N)
         RNM2 = DDOTPAK(N,R,1,R(NQ(3)),1)
         ALPH = ALF
C
         IF (RNM2*ORTFAC .GT. (ALF**2 + BET2) .OR. I .EQ. 2) RETURN
C
C....    REPEAT LOCAL REORTHOGONALIZATION WHEN WARRANTED
C
         DALF = DDOTPAK(N,R(NQ(1)),1,R(NQ(3)),1)
         DBET = DDOTPAK(N,R(NQ(2)),1,R(NQ(3)),1)
         CALL DAXPYPAK(N,-DBET,R(NQ(2)),1,R,1)
         BET = BET + DBET
         BET2 = BET**2
10    CONTINUE
C
      END
C
      SUBROUTINE ORTBND (ALF,BET,J,EPS1,ETA,OLDETA,TAU,OLDTAU,EIG,INFO,
     1                   RNM,NEIG,N)
C
C.... UPDATE THE ETA AND TAU RECURRENCES
C
C.... INPUTS
C
C     ALF(J)       DIAGONAL OF THE TRIDIAGONAL T
C     BET(J)       OFF-DIAGONAL OF T
C     J            DIMENSION OF T
C     EPS1         ROUNDOFF ESTIMATE FOR DOT PRODUCT OF TWO UNIT VECTORS
C     ETA(J)       ORTHOGONALITY ESTIMATE OF LANCZOS VECTORS AT STEP J
C     OLDETA(J)    ORTHOGONALITY ESTIMATE OF LANCZOS VECTORS AT STEP J-1
C     TAU(NEIG)    ORTHOGONALITY ESTIMATE OF RITZ VECTORS AT STEP J
C     OLDTAU(NEIG) ORTHOGONALITY ESTIMATE OF RITZ VECTORS AT STEP J-1
C     EIG(NEIG)    ARRAY OF CONVERGED EIGENVALUES
C     INFO(NEIG)   INFORMATION ARRAY ABOUT EIGENVECTORS OF T
C     RNM          NORM OF THE NEXT RESIDUAL VECTOR
C     NEIG         NUMBER OF CONVERGED EIGENVALUES
C     N            DIMENSION OF THE EIGENPROBLEM
C
C.... OUTPUTS
C
C     ETA(J)       ORTHOGONALITY ESTIMATE OF LANCZOS VECTORS AT STEP J+1
C     OLDETA(J)    ORTHOGONALITY ESTIMATE OF LANCZOS VECTORS AT STEP J
C     TAU(NEIG)    ORTHOGONALITY ESTIMATE OF RITZ VECTORS AT STEP J+1
C     OLDTAU(NEIG) ORTHOGONALITY ESTIMATE OF RITZ VECTORS AT STEP J
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION ALF(*),BET(*),ETA(*),OLDETA(*),TAU(*),OLDTAU(*)
      DIMENSION EIG(*),INFO(*)
      COMMON /LANCON/ ZERO, TENTH, EIGHTH, FOURTH, HALF, ONE, TWO,
     1                FOUR, TEN, ONE28, TWO56, FIVE12, ORTFAC, OVRFLW
C
      IF ( J. GT. 1 ) THEN
         OLDETA(1) = ( BET(2)*ETA(2) + (ALF(1) - ALF(J))*ETA(1)
     1               - BET(J)*OLDETA(1)) / RNM
         J1 = J - 1
         IF ( J .GT. 2 ) THEN
            DO 100 K=2,J1
               OLDETA(K) = (BET(K+1)*ETA(K+1) + (ALF(K) - ALF(J))*ETA(K)
     1                     + BET(K)*ETA(K-1) - BET(J)*OLDETA(K)) / RNM
100         CONTINUE
         END IF
         DO 200 K=1,J1
              T = OLDETA(K)
              OLDETA(K) = ETA(K)
              ETA(K) = T
200      CONTINUE
      END IF
      ETA(J) = EPS1*MAX(BET(2)/RNM,ONE)
C
C.... UPDATE THE TAU RECURRENCE
C
      DO 300 I=1,NEIG
         IF ( INFO(I) .NE. 0 ) THEN
            T = TAU(I)
            TAU(I) = (EIG(I) - ALF(J))*TAU(I) - BET(J)*OLDTAU(I)
            OLDTAU(I) = T
         END IF
300   CONTINUE
C
      RETURN
      END
C
      SUBROUTINE PURGE(R,Q,RA,QA,T,Y,ALF,BET,S,EIG,ETA,OLDETA,TAU,
     1                 OLDTAU,WORK,INFO,N,J,NBUF,IERR)
C
C.... THIS ROUTINE EXAMINES ETA, OLDETA, TAU AND OLDTAU TO DECIDE
C     WHICH FORM OF REORTHOGONALIZATION IF ANY SHOULD BE PERFORMED.
C
C.... INPUT/OUTPUT
C
C     R      THE RESIDUAL VECTOR TO BECOME THE NEXT LANCZOS VECTOR
C     Q      THE CURRENT LANCZOS VECTOR
C     RA     THE PRODUCT OF THE MASS MATRIX AND R
C     QA     THE PRODUCT OF THE MASS MATRIX AND Q
C     T      A TEMPORARY VECTOR TO HOLD THE PREVIOUS LANCZOS VECTORS
C     Y      CONTAINS THE COMPUTED RITZ VECTORS
C     ALF    THE NEW DIAGONAL OF T
C     BET    THE NEW OFF-DIAGONAL OF T
C     S      VECTOR FOR COMPUTING EIGENVECTORS OF T(J)
C     EIG    HOLDS THE CONVERGED RITZ VALUES
C     ETA    STATE OF ORTHOGONALITY BETWEEN R AND PREVIOUS LANC. VECTORS
C     OLDETA STATE OF ORTHOGONALITY BETWEEN Q AND PREVIOUS LANC. VECTORS
C     TAU    STATE OF ORTHOGONALITY BETWEEN R AND COMPUTED RITZ VECTORS
C     OLDTAU STATE OF ORTHOGONALITY BETWEEN Q AND COMPUTED RITZ VECTORS
C     WORK   WORKING ARRAY EXPLAINED IN LANSEL
C     INFO   INFORMATION ABOUT THE EIGENVECTORS OF T(J)
C     N      DIMENSION OF THE EIGENPROBLEM
C     J      CURRENT LANCZOS STEP
C     NEIG   NUMBER OF RITZ VALUES
C     NBUF   NUMBER OF VECTORS IN S
C
C.... SUBROUTINES: DAXPYPAK,DZERO,DDOTPAK,GIVENS,IDAMAXPAK,OPM,RITVEC,SUBTJ
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION R(*),Q(*),RA(*),QA(*),T(*),Y(N,*),ALF(*),BET(*),S(J,*)
      DIMENSION EIG(*),ETA(*),OLDETA(*),TAU(*),OLDTAU(*),INFO(*),WORK(*)
      LOGICAL ORTHO
C
      include 'paka.inc'
      
      COMMON /REPERI/ LCORD,LID,LMAXA,LMHT
      COMMON /LANCZO/ LA,LB,LTT,LW
      COMMON /IDATA/ EIGL,EIGR,NEIG
      COMMON /RDATA/ RNM,RNM2,SPREAD,TOL,EPS,EPS1,REPS
      COMMON /LANCON/ ZERO, TENTH, EIGHTH, FOURTH, HALF, ONE, TWO,
     1                FOUR, TEN, ONE28, TWO56, FIVE12, ORTFAC, OVRFLW
C
      ORTHO  = .FALSE.
      TOLL    = REPS*SPREAD
      REPSOJ = DSQRT(EPS/FLOAT(J))
      K      = IDAMAXPAK(J-2,ETA,1)
      IF (DABS(ETA(K)) .GT. REPSOJ) THEN
         DO 10 I=1,NEIG
            IF (INFO(I) .LT. 0 .AND. DABS(TAU(I)) .GT. REPSOJ) THEN
               CALL DZERO(J,S,1)
               CALL SUBTJ(ALF,BET,EIG,INFO,TOLL,I,N,NEIG,J,L,K,M,
     1                    WORK,IERR)
               IF (IERR .GT. 0) RETURN
               CALL GIVENS(K-M+1,L-M+1,ALF(M),BET(M),EIG(I),EPS,
     1                     S,RESID,RAYCOR,IERR)
               IF (IERR .GT. 0) RETURN
               ZETA = -DDOTPAK(J,ETA,1,S,1)
               CALL DAXPYPAK(J,ZETA,S,1,ETA,1)
               ZETA = -DDOTPAK(J,OLDETA,1,S,1)
               CALL DAXPYPAK(J,ZETA,S,1,OLDETA,1)
            END IF
10       CONTINUE
C
         K = IDAMAXPAK(J-2,ETA,1)
C
         IF (DABS(ETA(K)) .GT. REPSOJ) THEN
C
C....       GRAM-SCHMID NEEDED
C
            ORTHO = .TRUE.
            CALL RITVEC(R,Q,RA,QA,T,Y,ALF,BET,EIG,S,INFO,N,J,NEIG,
     1                  NBUF,.FALSE.,WORK,IERR)
            IF (IERR.GT.0) RETURN
            DO 20 I=1,NEIG
               TAU(I) = EPS1
               OLDTAU(I) = EPS1
20          CONTINUE
            DO 30 I=1,J-1
               ETA(I) = EPS1
               OLDETA(I) = EPS1
30          CONTINUE
         ELSE
C
C....       REMOVE COMPONENTS OF A RITZ VECTOR
C
            ORTHO = .TRUE.
            DO 40 I = 1,NEIG
               IF (DABS(TAU(I)).GT.REPSOJ)THEN
                  TAU(I) = EPS1
                  OLDTAU(I) = EPS1
                  ZETA = DDOTPAK(N,RA,1,Y(1,I),1)
                  CALL DAXPYPAK(N,-ZETA,Y(1,I),1,R,1)
                  ZETA = DDOTPAK(N,QA,1,Y(1,I),1)
                  CALL DAXPYPAK(N,-ZETA,Y(1,I),1,Q,1)
               END IF
40          CONTINUE
         END IF
      END IF
      IF (ORTHO) THEN
         CALL OPM(A(LB),A(LMAXA),Q,QA,N)
         QNORM = DSQRT(DDOTPAK(N,Q,1,QA,1))
         CALL DSCALPAK(N,ONE/QNORM,Q,1)
         CALL DSCALPAK(N,ONE/QNORM,QA,1)
         BET(J) = BET(J) * QNORM
         ZETA   = DDOTPAK(N,R,1,QA,1)
         ALF(J) = ALF(J) + ZETA
         CALL DAXPYPAK(N,-ZETA,Q,1,R,1)
         CALL OPM(A(LB),A(LMAXA),R,RA,N)
         RNM2 = DDOTPAK(N,R,1,RA,1)
         RNM  = DSQRT(RNM2)
      END IF
C
      RETURN
      END
C
      SUBROUTINE RITVEC(R,Q,RA,QA,T,Y,ALF,BET,EIG,S,INFO,N,J,NEIG,NBUF,
     1                 EVONLY,WORK,IERR)
C
C.... THIS ROUTINE COMPUTES SOME RITZ VECTORS AND PERFORMS A
C     REORTHOGONALIZATION OF THE LANCZOS VECTORS.
C
C.... INPUT/OUTPUT
C
C     R      THE RESIDUAL VECTOR TO BECOME THE NEXT LANCZOS VECTOR
C     Q      THE CURRENT LANCZOS VECTOR
C     RA     THE PRODUCT OF MASS MATRIX AND R
C     QA     THE PRODUCT OF MASS MATRIX AND Q
C     T      A TEMPORARY VECTOR TO HOLD THE PREVIOUS LANCZOS VECTORS
C     Y      CONTAINS THE COMPUTED RITZ VECTORS
C     ALF    THE NEW DIAGONAL OF T
C     BET    THE NEW OFF-DIAGONAL OF T
C     EIG    HOLDS THE CONVERGED RITZ VALUES
C     S      VECTOR FOR COMPUTING EIGENVECTORS OF T(J)
C     INFO   INFORMATION ABOUT THE EIGENVECTORS OF T(J)
C     N      DIMENSION OF THE EIGENPROBLEM
C     J      CURRENT LANCZOS STEP
C     NEIG   NUMBER OF RITZ VALUES
C     NBUF   NUMBER OF VECTORS IN S
C     EVONLY IF.TRUE.NO REORTHO.IS PERFORMED,COMPUTES ONLY RITZ VECTORS
C
C.... SUBROUTINES: DAXPYPAK,DDOTPAK,DZERO,GIVENS,IDAMAXPAK,NUMLES,STORE
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION R(*),Q(*),RA(*),QA(*),T(*),Y(N,1),ALF(*),BET(*),S(J,1)
      DIMENSION EIG(1),INFO(1),WORK(1)
      LOGICAL EVONLY
C
      COMMON /RDATA/ RNM,RNM2,SPREAD,TOL,EPS,EPS1,REPS
      COMMON /LANCON/ ZERO, TENTH, EIGHTH, FOURTH, HALF, ONE, TWO,
     1                FOUR, TEN, ONE28, TWO56, FIVE12, ORTFAC, OVRFLW
C
C     EPS14 = EPS**(1/4)
C     TOL14 = EPS**(1/4)*SPREAD
C     TOL34 = EPS**(3/4)*SPREAD
C
      EPS14 = DSQRT(REPS)
      TOL14 = EPS14*SPREAD
      TOL34 = REPS*TOL14
C
      IBUF = 0
      TOLL = REPS*SPREAD
      RNEPS = RNM*EPS
C
C.... COMPUTE EIGENVECTORS OF T AND PUT IN THE BUFFER.
C
      DO 30 I=NEIG,1,-1
         IF (INFO(I) .GE. 0 .AND. IBUF .LT. NBUF) THEN
            IF (EVONLY .AND. INFO(I) .NE. 0) GO TO 30
            IBUF = IBUF + 1
            CALL DZERO(N,Y(1,I),1)
C
C....       EIG(I) ISOLATED
C
            M = 1
            L = J
            K = M
            CALL DZERO(J,S(1,IBUF),1)
            CALL GIVENS(K-M+1,L-M+1,ALF(M),BET(M),EIG(I),EPS1,
     1         S(M,IBUF),RESID,RAYCOR,IERR)
            IF (IERR .GT. 0) GO TO 900
            IF (RESID .LE. TOL14) GO TO 15
C
C....       CHECK THAT EIG(I) IS AN EIGENVALUE OF T
C
            DO 5 IDUM = M, L
               WORK(IDUM) = BET(IDUM)*BET(IDUM)
 5          CONTINUE
            ZETA = EIG(I)*(ONE - EPS14)
            NUL = NUMLES(ALF(M),WORK(M),ZETA,L-M+1,1,EPS)
            ZETA = EIG(I)*(ONE + EPS14)
            NUR = NUMLES(ALF(M),WORK(M),ZETA,L-M+1,1,EPS)
C
C....       EIG(I) IS NOT AN EIGENVALUE OF T, GOODBYE.
C
            IF (NUR .EQ. NUL) THEN
               IERR = IERR + 1024
               GO TO 900
            ENDIF
C
C....       EIG(I) IS O.K., NOW FIND A GOOD K
C
            DO 10 K=M+1,L
               CALL DZERO(J,S(1,IBUF),1)
               CALL GIVENS(K-M+1,L-M+1,ALF(M),BET(M),EIG(I),EPS1,
     1                     S(M,IBUF),RESID,RAYCOR,IERR)
               IF (IERR.GT.0) GO TO 900
               IF (RESID .LE. TOL14) GO TO 15
10          CONTINUE
C
C....       NO SUITABLE K WAS FOUND, GOODBYE.
C
            IERR = IERR + 512
            GO TO 900
C
C....       NOW WE CAN REFINE THE EIGENVECTOR
C
15          DO 20 LOOP = 1,10
               K = IDAMAXPAK(L-M+1,S(M,IBUF),1)+M-1
               CALL DZERO(J,S(1,IBUF),1)
               CALL GIVENS(K-M+1,L-M+1,ALF(M),BET(M),EIG(I),EPS1,
     1                     S(M,IBUF),RESID,RAYCOR,IERR)
               IF (RESID.LE.TOLL) GO TO 25
               EIG(I) = EIG(I) + RAYCOR
20          CONTINUE
C
C....       RESID FAILED TO DIMINISH, GOODBYE.
C
            IF (RESID .GT. TOLL) THEN
               IERR = IERR + 2048
               GO TO 900
            ENDIF
C
25          INFO(I) = N*IDAMAXPAK(J,S(1,IBUF),1)+J-1
         END IF
30    CONTINUE
C
C.... COMPUTE THE RITZ VECTORS AND PERFORM G-S ORTHOGONALIZATION.
C
      DO 50 I=1,J-1
C
C....    RETRIEVING THE LANCZOS VECTOR AND PUT IT IN T
C
         CALL STORE(T,N,I,2)
         KBUF = 0
         DO 40 K=NEIG,1,-1
            IF (INFO(K) .GE. 0 .AND. KBUF .LT. IBUF) THEN
               KBUF = KBUF + 1
               SI = S(I,KBUF)
               IF (DABS(SI) .GT. EPS) CALL DAXPYPAK(N,SI,T,1,Y(1,K),1)
            END IF
40       CONTINUE
         IF (.NOT.EVONLY) THEN
            ZETOLD = -DDOTPAK(N,QA,1,T,1)
            IF ( DABS(ZETOLD) .GT. EPS ) CALL DAXPYPAK(N,ZETOLD,T,1,Q,1)
            ZETA = -DDOTPAK(N,RA,1,T,1)
            IF ( DABS(ZETA) .GT. RNEPS ) CALL DAXPYPAK(N,ZETA,T,1,R,1)
         END IF
50    CONTINUE
C
C.... ADD IN CONTRIBUTION OF QJ TO Y
C
      KBUF = 0
      DO 60 I=NEIG,1,-1
         IF (INFO(I) .GE. 0 .AND. KBUF .LT. IBUF) THEN
            KBUF = KBUF + 1
            IF (DABS(S(J,KBUF)) .LT. EPS1) INFO(I) = -INFO(I)
            CALL DAXPYPAK(N,S(J,KBUF),Q,1,Y(1,I),1)
         END IF
60    CONTINUE
C
900   RETURN
      END
C
      SUBROUTINE GIVENS(K,J,ALF,BET,THET,EPS,S,RES,COR,IERR)
C
C.... GIVENS RECURRENCE FOR COMPUTING EIGENVECTORS OF A TRIDIAGONAL T.
C
C.... INPUTS
C
C     K      INDEX OF THE RIGHT HAND SIDE E(K)
C     J      DIMENSION OF THE TRIDIAGONAL MATRIX
C     ALF(J) DIAGONALS OF T
C     BET(J) OFF-DIAGONALS OF T
C     THET   EIGENVALUE OF T
C     EPS    COMPUTER PRECISION
C
C.... OUTPUTS
C
C     S(J)   COMPUTED EIGENVECTOR
C     RES    NORM OF RESIDUAL
C     COR    RAYLEIGH CORRECTION FOR THET
C
C.... SUBROUTINES : DSCALPAK
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION ALF(J),BET(J),S(J)
C
C.... OVRFLW IS MACHINE OVERFLOW THRESHOLD
C
      COMMON /LANCON/ ZERO, TENTH, EIGHTH, FOURTH, HALF, ONE, TWO,
     1                FOUR, TEN, ONE28, TWO56, FIVE12, ORTFAC, OVRFLW
C
C.... BACKWARD RECURRENCE
C
      BIG = DSQRT(OVRFLW/FLOAT(J+1))
      RES = ZERO
C
      S(J) = ONE
      SUM2 = ONE
      IF ( K .LT. J ) THEN
         S(J-1) = -(ALF(J) - THET)*S(J)/BET(J)
         SUM2 = SUM2 + S(J-1)**2
      END IF
      DO 10 I = J-1,K+1,-1
         S(I-1) = -((ALF(I) - THET)*S(I) + BET(I+1)*S(I+1))/BET(I)
C
C....    SCALE TO AVOID OVERFLOW
C
         IF ( DABS(S(I-1)) .GT. BIG ) THEN
            F = ONE/S(I-1)
            S(I-1) = ONE
            CALL DSCALPAK(J-I+1,F,S(I),1)
            SUM2 = (SUM2*F)*F
         END IF
         SUM2 = SUM2 + S(I-1)**2
10    CONTINUE
C
C.... STOP EXECUTION GRACEFULLY IF S(K) IS EXACTLY ZERO
C
C     IF (S(K) .EQ. ZERO) THEN
      IF (DABS(S(K) - ZERO).LT.1.0D-30) THEN
         IERR = IERR + 256
         RETURN
      ENDIF
      F = ONE/S(K)
      S(K) = ONE
      SUM2 = (SUM2*F)*F
      CALL DSCALPAK(J-K,F,S(K+1),1)
      IF ( K .LE. 1 ) GO TO 30
C
C.... FORWARD RECURRENCE
C
         X = ZERO
         S(1) = ONE
         SUM1 = ONE
         IF ( K .GT. 2 ) THEN
            S(2) = -((ALF(1) - THET)*S(1))/BET(2)
            SUM1 = SUM1 + S(2)**2
            DO 20 I = 2,K-2
               S(I+1) = -((ALF(I) - THET)*S(I) + BET(I)*S(I-1))/BET(I+1)
               IF ( DABS(S(I+1)) .GT. BIG ) THEN
                  F = ONE/S(I+1)
                  S(I+1) = ONE
                  CALL DSCALPAK(I,F,S,1)
                  SUM1 = (SUM1*F)*F
               END IF
               SUM1 = SUM1 + S(I+1)**2
20          CONTINUE
            X = BET(K-1)*S(K-2)
         END IF
         X = -(X + (ALF(K-1) - THET)*S(K-1))/BET(K)
C
C....    MATCH X WITH S(K)
C
C        IF ( X .EQ. ZERO ) THEN
         IF (DABS( X - ZERO).LT.1.0D-30 ) THEN
            RES = ONE
            RETURN
         END IF
         F = S(K)/X
         CALL DSCALPAK(K-1,F,S,1)
         SUM2 = SUM2 + SUM1*F**2
         RES = BET(K)*S(K-1)
C
C.... NORMALIZE S
C
30    F = ONE/DSQRT(SUM2)
      CALL DSCALPAK(J,F,S,1)
      RES = RES*F + (ALF(K) - THET)*S(K)
      IF ( K .LT. J ) RES = RES + BET(K+1)*S(K+1)
      COR = S(K)*RES
      RES = DABS(RES)
C
      RETURN
      END
C
      SUBROUTINE SUBTJ(ALF,BET,EIG,INFO,TOLL,I,N,NEIG,J,L,K,M,
     1                 U,IERR)
C
C.... THIS ROUTINE SCANS BACK THROUGH THE CONVERGED EIGENVALUES
C     FOR COPIES OF EIG(I) TO DETERMINE THE SUBMATRIX T(M,L) AND
C     THE RIGHT HAND SIDE E(K) FOR THE GIVENS RECURRENCE.
C
C.... INPUTS
C
C     EIG(NEIG)    LIST OF THE CONVERGED EIGENVALUES
C     INFO(NEIG)   INFORMATION ABOUT THE EIGENVECTORS
C     TOL          TOLERANCE FOR FINDING COPIES OF EIG(I)
C     I            INDEX OF THE EIGENVALUE CONSIDERED
C     N            DIMENSION OF THE EIGENPROBLEM
C     NEIG         NUMBER OF EIGENVALUES IN EIG
C
C.... OUTPUTS
C
C     K            INDEX OF THE RIGHT HAND SIDE FOR GIVENS
C     L            INDEX OF THE LAST ELEMENT OF THE SUBMATRIX
C     M            INDEX OF THE FIRST ELEMENT OF THE SUBMATRIX
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION ALF(*),BET(*),EIG(*),INFO(*),U(*)
C
      COMMON /RDATA/ RNM,RNM2,SPREAD,TOL,EPS,EPS1,REPS
      COMMON /LANCON/ ZERO, TENTH, EIGHTH, FOURTH, HALF, ONE, TWO,
     1                FOUR, TEN, ONE28, TWO56, FIVE12, ORTFAC, OVRFLW
C
      L = J
      EIGI = EIG(I)
C
C.... CHECK SPECIAL CASE OF EIGI = ALL ALTERNATE ALF'S
C
      DO 10 JM = J,1,-2
         IF (DABS(ALF(JM)-EIGI) .GE. EPS*SPREAD) GO TO 20
10    CONTINUE
C
C.... FALSE RITZ VALUE ACCEPTED, STOP EXECUTION GRACEFULLY.
C
      IERR = IERR + 2048
      RETURN
C
C.... RUN RECURRENCE UNTIL "PIVOT = DIAGONAL" TO FIND M
C
20    U(JM) = (ALF(JM)-EIGI)*(ONE - TEN*EPS)
      UMIN  = DABS(U(JM))
      IUMIN = JM
      DO 30 M = JM-1,1,-1
         U(M) = ALF(M)-EIGI-BET(M+1)**2/U(M+1)
         IF (DABS(U(M)).LT.TOLL*EIGHTH) GO TO 40
         IF (DABS(U(M)).LE.UMIN) THEN
            UMIN = M
         ENDIF
30    CONTINUE
C
C.... TEMPORARILY
C
      M = IUMIN
C
C.... NOW SET K
C
40    IF (M .EQ. 1) THEN
         K = M
      ELSE
         K = M+1
      ENDIF
C
C.... NOW CHECK FOR CLOSE EIGENVALUES
C
      IF (M .GT. 1) THEN
         DO 50 I1 = I-1,1,-1
            IF (DABS(EIGI-EIG(I1)).LT.ONE28*EPS*SPREAD)
     1         GO TO 60
50       CONTINUE
C
         RETURN
C
60       KPREV = MOD(IABS(INFO(I1)),N)
         IF (KPREV .LE. K) K = KPREV+1
      ENDIF
C
C.... FIND L
C
      DO 200 I2 = I+1,NEIG
         IF (DABS(EIGI - EIG(I2)) .LT. TOLL) GO TO 210
200   CONTINUE
210   IF (I2 .LE. NEIG) THEN
         L = IABS(INFO(I2))/N-1
         IF (INFO(I2) .EQ. 0) L = MOD(IABS(INFO(I)),N)
      END IF
C
      RETURN
      END
C
      SUBROUTINE ANALZT(J,ALF,BET2,EIG,TAU,OLDTAU,RHO,INFO)
C
C.... THIS ROUTINE UPDATES SOME EIGENVALUES OF A TRIDIAGONAL T(J) USING
C     THE EIGENVALUES OF T(J-1).
C
C.... INPUTS
C
C     J         ORDER OF THE TRIDIAGONAL T.
C     ALF       DIAGONAL OF T.
C     BET2      SQUARES OF THE OFFDIAGONAL TERMS. BET2(1) = ZERO
C     EIG       ARRAY OF CONVERGED EIGENVALUES
C     TAU       ORTHOGONALITY ESTIMATE OF RITZ VECTORS AT STEP J
C     OLDTAU    ORTHOGONALITY ESTIMATE OF RITZ VECTORS AT STEP J-1
C     RHO       WORKING ARRAY USED IN DEFLAT
C     INFO      INFORMATION ARRAY ABOUT EIGENVECTORS OF T
C
C.... INTERNAL VARIABLES
C
C     THET      EXTERIOR EIGENVALUES OF T, NEARLY CONVERGED
C               RITZ VALUES. THET(1)=LEFTMOST, THET(NDST)=RIGHTMOST.
C     NDST      SIZE OF THET AND BJ
C     BJ        ERROR BOUND ON THET
C               BJ(I) IS SET TO -1 IF THET(I) DISAPPEARS.
C     NBD       CONTAINS L AND R IN THE TEXT.
C     SPREAD    THET(NDST) - THET(1)
C     EPS       PRECISION OF ARITHMETIC OPERATIONS
C     IP        IP =1 FOR UPDATING LEFT END, IP = 2 FOR THE RIGHT END.
C     INC       INC=1 FOR UPDATING LEFT END, INC=-1 FOR THE RIGHT END.
C     IS        STARTING INDEX (EITHER 1 OR NDST)
C     START     LEFT BOUND ON EIGENVALUES (INC=1), RIGHT BOUND (INC=-1)
C     PROBE     THE OUTER END OF THE NEXT SUBINTERVAL TO BE UPDATED.
C     INDXOK    TRUE, IF THERE ARE I-INC RITZ VALUES EXTERIOR TO THE
C               NEW THET(I).
C
C.... SUBROUTINES: DEFLAT,MOVE1,NEWCOR,NUMLES
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (NMAX = 128)
C
      DIMENSION ALF(*),BET2(*),EIG(*),TAU(*),OLDTAU(*),RHO(*),INFO(*)
      LOGICAL INSERT,INDXOK,APPEND
C
      COMMON /RDATA/ RNM,RNM2,SPREAD,TOL,EPS,EPS1,REPS
      COMMON /ATDATA/ THET(NMAX),BJ(NMAX),WINDOW,NBD(2),NDST
      COMMON /IDATA/ EIGL,EIGR,NEIG
      COMMON /LANCON/ ZERO, TENTH, EIGHTH, FOURTH, HALF, ONE, TWO,
     1                FOUR, TEN, ONE28, TWO56, FIVE12, ORTFAC, OVRFLW
C
      IF (J.LE.1) RETURN
      IF (J.EQ.2) THEN
         NDST = 16
         WINDOW = FOURTH/DSQRT(REPS)
         THET(1) = (ALF(1) + ALF(2) - DSQRT(FOUR*BET2(2) +
     1             (ALF(1) - ALF(2))**2))*HALF
         THET(NDST) = ALF(1) + ALF(2) - THET(1)
         BJ(1) = DSQRT(RNM2/(ONE + BET2(2)/(THET(1) - ALF(1))**2))
         BJ(NDST) = DSQRT(RNM2/(ONE + BET2(2)/(THET(NDST) - ALF(1))**2))
         NBD(1) = 1
         NBD(2) = NDST
         SPREAD = THET(NDST) - THET(1)
         RETURN
      END IF
      SPREAD = THET(NDST) -THET(1)
      TOL = TWO*REPS*SPREAD
      W = WINDOW*TOL
C
C.... BEGIN PHASE 1.
C
C.... LOOP FOR LEFT END,THEN RIGHT
C
      DO 100 IP = 1,2
         INC = 3 - 2*IP
         IS = (NDST-1)*IP - (NDST-2)
         I = IS
         INSERT = .FALSE.
         START = (THET(I) + ALF(J) - INC*DSQRT(BET2(J)*FOUR +
     1           (ALF(J) - THET(I))**2))*HALF
         PROBE = THET(I) - INC*BJ(I)
         INDXOK = NUMLES(ALF,BET2,PROBE,J,INC,EPS) .EQ. 0
C
         DO 50 IDUMMY =1,NDST
C
            IF (I-NBD(IP).EQ.INC) GO TO 100
C
C....       EXAMINE I-TH SUBINTERVAL
C
            IF (INDXOK) THEN
               IF (INSERT) THEN
                  START = THET(I)
                  THET(I) = START + INC*MIN(B**2/
     1               DABS(START-THET(I-INC)),B)
               ELSE
                  IF (INT(DSIGN(ONE,PROBE-START)).EQ.INC) START = PROBE
               END IF
C
C....          CHECK FOR DISJOINT SUBINTERVALS
C
               IF (I .EQ. NBD(IP)) THEN
                  PROBE=THET(I)+INC*(THET(NBD(2))-THET(NBD(1)))/(FOUR*J)
               ELSE
                  PROBE = THET(I+INC) - INC*BJ(I+INC)
               END IF
               IF (INT(DSIGN(ONE,PROBE-THET(I))).EQ.INC) THEN
C
C....             CHECK FOR AN EXTRA RITZ VALUE
C
                  K = NUMLES(ALF,BET2,PROBE,J,INC,EPS)
C
                  IF (K.LT. IABS(I-IS+INC)) THEN
C
C....                THET(I) DISAPPEARS
C
                     BJ(I) = -ONE
                  ELSE
C
C....                RECORD INDXOK FOR NEXT LOOP. USE REFINED BOUNDS.
C
                     IF (.NOT.INSERT) THEN
                        B = BJ(I)
                        INDXOK = (K .LE. IABS(I-IS+INC))
                        BND = MIN(B**2/DABS(PROBE-THET(I)),B)
                        IF (INDXOK.AND.BND.LT.DABS(THET(I)-START)) THEN
                           START = THET(I) - INC*BND
                        END IF
                     END IF
                  END IF
               END IF
            ELSE
C
C....          PREPARE FOR AN INTRUDING RITZ VALUE
C
               IF ((IS.EQ.NBD(IP).OR.BJ(NBD(IP)-INC).LT.W).AND.
     1             NBD(2)-NBD(1).GT.1) NBD(IP) = NBD(IP) + INC
               CALL MOVE1(THET,I,NBD(IP),-INC,PROBE)
               CALL MOVE1(BJ,I,NBD(IP),-INC,TWO*TOL)
               INSERT = .TRUE.
               INDXOK = .TRUE.
            END IF
C
            IF (BJ(I).GT.TOL) THEN
C
C....       USE NEWTON ITERATION TO FIND NEW THET(I)
C
               CALL NEWCOR(ALF,BET2,START,THET,BJ,INC,I,J,NDST)
C
            END IF
C
            IF (BJ(I).LT.0) THEN
C
C....          THET(I) DISAPPEARS
C
               CALL MOVE1(THET,NBD(IP),I,INC,ZERO)
               CALL MOVE1(BJ,NBD(IP),I,INC,ZERO)
               NBD(IP) = NBD(IP) - INC
               INSERT = .FALSE.
               INDXOK = .TRUE.
C
C
               I = I - INC
            END IF
            I = I + INC
50       CONTINUE
C
C....    END OF PHASE 1
C
100   CONTINUE
C
C.... BEGIN PHASE 2.
C
C.... APPEND MORE RITZ VALUES AND CHECK FOR CONVERGED RITZ VALUES.
C
      DO 200 IP = 1,2
         INC = 3 -2*IP
         IS = (NDST-1)*IP - (NDST-2)
         I = IS
         DO 150 IDUMMY = 1,J
            NREM = J - NBD(1) - ((NDST+1) - NBD(2))
            IF ((I-NBD(IP))*INC.GT.0) GO TO 200
            APPEND = I.EQ.NBD(IP).AND.(BJ(I).LT.W.OR.(J.EQ.4
     1               .AND.NBD(IP).EQ.IS)).AND.NREM.GT.0
            IF (APPEND) THEN
               START = THET(I) + FLOAT(INC)*BJ(I)
               PROBE = INC*(THET(NBD(2)) - THET(NBD(1)))/NREM
            END IF
            IF (BJ(I) .LE. TOL) THEN
C
C....          APPLY QR ALGOR. TO DEFLATE
C
               CALL DEFLAT(ALF,BET2,THET(I),J)
C
C....          INSERT THET(I) INTO EIG
C
               NEIG = NEIG + 1
               IF (IP.EQ.1) THEN
                  EIGL = MAX(EIGL,THET(I))
               ELSE
                  EIGR = MIN(EIGR,THET(I))
               END IF
               EIG(NEIG) = THET(I)
               INFO(NEIG) = 0
C
C....          REMOVE STABILIZED RITZ VALUES
C
               CALL MOVE1(THET,NBD(IP),I,INC,ZERO)
               CALL MOVE1(BJ,NBD(IP),I,INC,ZERO)
               NBD(IP) = NBD(IP) - INC
               I = I - INC
            END IF
            IF (APPEND.AND.NBD(2)-NBD(1).GT.1) THEN
               T = START + PROBE
               NBD(IP) = NBD(IP) + INC
               IK = IABS(IS - NBD(IP))
               DO 110 IDUM = 1,J
                  IF (NUMLES(ALF,BET2,T,J,INC,EPS).NE.IK) GO TO 120
                  T = T + PROBE
110            CONTINUE
120            THET(NBD(IP)) = T
               START = T - PROBE
               CALL NEWCOR(ALF,BET2,START,THET,BJ,INC,NBD(IP),J,NDST)
C
            END IF
            IF (J.GT.NDST.AND.I.EQ.NBD(IP).AND.I.NE.IS.AND.BJ(I).GT.
     1          BJ(I-INC).AND.BJ(I-INC).GT.W) NBD(IP) = NBD(IP) - INC
            I = I + INC
150      CONTINUE
200   CONTINUE
C
C.... RE-ESTABLISH AN END MARKER, IF NECESSARY, AT EARLY STAGE
C
      DO 300 IP = 1,2
         INC = 3 - 2*IP
         IS = (NDST-1)*IP - (NDST-2)
         IF (NBD(IP).EQ.IS-INC) THEN
            THET(IS) = THET(NBD(3-IP))
            BJ(IS) = BJ(NBD(3-IP))
            NBD(IP) = IS
            NBD(3-IP) = NBD(3-IP) + INC
         END IF
300   CONTINUE
C
      RETURN
      END
C
      SUBROUTINE NEWCOR(ALF,BET2,ZETA,THET,BJ,INC,INDX,J,NDST)
C
C.... COMPUTES EXTERIOR EIGENVALUES OF A TRIDIAGONAL USING A
C     COMBINATION OF BISECTIONS AND NEWTON'S METHOD
C
C.... INPUT
C
C     ALF       DIAGONAL OF T
C     BET2      SQUARES OF THE OFFDIAGONAL TERMS, BET2(1) = ZERO
C     SPREAD    THET(NDST) - THET(1)
C     INC       INC=1 FOR UPDATING LEFT END, INC=-1 FOR RIGHTEND.
C     INDX      INDEX OF TO-BE-UPDATING THET.
C     J         ORDER OF THE TRIDIAGONAL T.
C     NDST      SIZE OF THET AND BJ
C
C.... INPUT/OUTPUT
C     ZETA      EXTERIOR BOUND FOR EIGENVALUE OF T IN THET(INDX)
C     THET      EXTERIOR EIGENVALUES OF T, NEARLY CONVERGED RITZ VALUES;
C               THET(1)=LEFTMOST,THET(NDST)=RIGHTMOST.
C     BJ        ERROR BOUND ON THET
C
C     SUBROUTINES: NUMLES,QLBOT
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (MAXBIS = 15, MAXNEW = 40)
      DIMENSION ALF(*),BET2(*),THET(*),BJ(*)
C
      COMMON /RDATA/ RNM,RNM2,SPREAD,TOL,EPS,EPS1,REPS
      COMMON /LANCON/ ZERO, TENTH, EIGHTH, FOURTH, HALF, ONE, TWO,
     1                FOUR, TEN, ONE28, TWO56, FIVE12, ORTFAC, OVRFLW
C
      ZOLD = ZETA
      IF (J .EQ. 1) THEN
         ZETA = THET(INDX)
         THET(INDX) = ALF(J)
         BJ(INDX) = DSQRT(RNM2)
         RETURN
      END IF
C
C.... PERFORM BISECTION FOR AN IMPROVED ZETA
C
      IS = ((NDST+1) - (NDST-1)*INC)/2
      DFLJ=FLOAT(J)
      FACT = FIVE12*FLOAT(J)*DLOG(DFLJ)
      WIDTH = (THET(INDX) - ZETA)*HALF
C     IF (WIDTH .EQ. ZERO) THEN
      IF (DABS(WIDTH - ZERO).LT.1.0D-30) THEN
         WIDTH = BJ(INDX)*HALF
      ENDIF
      IOLD = IABS(IS - INDX)
      DO 10 IDUMMY = 1,MAXBIS
         IF (DABS(WIDTH)*FACT .LE. DABS(THET((NDST+1)-IS)-THET(INDX)))
     1      GO TO 20
         ZNEW = ZETA + WIDTH
         INEW = NUMLES(ALF,BET2,ZNEW,J,INC,EPS)
         WIDTH = WIDTH*HALF
         IF (INEW .EQ. IOLD) THEN
            ZETA = ZNEW
         ENDIF
C
10    CONTINUE
20    CONTINUE
C
      DO 50 IDUMMY = 1,MAXNEW
         U = ALF(1) - ZETA
C        IF ( U .EQ. ZERO ) U = TENTH*EPS*BET2(2)
         IF (DABS( U - ZERO).LT.1.0D-30 ) U = TENTH*EPS*BET2(2)
         RAT = ONE/U
         SUM = RAT
         DO 30 I = 2,J
            H   = BET2(I)/U
            U = ALF(I) - ZETA - H
C           IF ( U .EQ. ZERO ) U = TENTH*EPS*(H + BET2(I))
            IF(DABS(U-ZERO).LT.1.0D-30 ) U = TENTH*EPS*(H + BET2(I))
            RAT = ( ONE + H*RAT )/U
            SUM = SUM + RAT
30       CONTINUE
         BOT2 = U*SUM
C
C....    DEFLATION
C
         DO 40 I = IS,INDX-INC,INC
            DEL = ZETA - THET(I)
            IF (DABS(DEL).LT.EPS*DABS(ZETA)) THEN
               DEL = EPS*DABS(ZETA)
            ENDIF
            SUM = SUM + ONE/DEL
40       CONTINUE
C
C....    CHECK FOR CONVERGENCE
C
         ZNEW = ZETA + ONE/SUM
         ZETA = ZNEW
C        IF (SPREAD+TENTH/SUM.EQ.SPREAD.OR.
         IF (DABS(SPREAD+TENTH/SUM-SPREAD).LT.1.0D-30.OR.
     1      FLOAT(INC)/SUM.LT.ZERO) THEN
            GO TO 60
         ENDIF
50    CONTINUE
60    CONTINUE
C
      CALL QLBOT(ALF,BET2,ZETA,BOT2,J)
C
      ZNEW = THET(INDX)
      THET(INDX) = ZETA
      ZETA = ZNEW
      BJ(INDX) = DSQRT(RNM2*BOT2)
C
      RETURN
      END
C
      SUBROUTINE DEFLAT(ALF,BET2,THET,J)
C
C.... THIS ROUTINE PERFORMS DEFLATION OF T USING SHIFT THET.
C
C.... INPUTS
C
C     ALF(J)    DIAGONALS OF T
C     BET2(J)   SQUARES OF OFF-DIAGONALS OF T
C     THET      EIGENVALUE OF T TO BE DEFLATED EXPLICITLY
C     J         DIMENSION OF THE TRIDIAGONAL MATRIX
C
C.... OUTPUTS
C
C     ALF(J-1)  MODIFIED DIAGONALS OF T
C     BET2(J-1) MODIFIED OFF-DIAGONALS OF T
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (MAXITR = 3)
      DIMENSION ALF(J),BET2(J)
C
      COMMON /RDATA/ RNM,RNM2,SPREAD,TOL,EPS,EPS1,REPS
      COMMON /LANCON/ ZERO, TENTH, EIGHTH, FOURTH, HALF, ONE, TWO,
     1                FOUR, TEN, ONE28, TWO56, FIVE12, ORTFAC, OVRFLW
C
C.... PWK ALGORITHM
C
      DO 200 LOOP=1,MAXITR
         C = ONE
         S = ZERO
         G = ALF(1) - THET
         P = G**2
         DO 100 I=1,J-1
            B = BET2(I+1)
            R = P + B
            BET2(I) = S*R
            OLDC = C
            C = P/R
            S = B/R
            OLDG = G
            A = ALF(I+1)
            G = C*(A - THET) - S*OLDG
            ALF(I) = OLDG + (A - G)
C           IF ( C .EQ. ZERO ) THEN
            IF (DABS( C - ZERO).LT.1.0D-30 ) THEN
               P = OLDC*B
            ELSE
               P = G*(G/C)
            END IF
100      CONTINUE
         BET2(J) = S*P
         ALF(J) = G + THET
         IF (BET2(J) .LE. EPS*SPREAD) THEN
            GOTO 300
         ENDIF
200   CONTINUE
300   J = J - 1
C
      RETURN
      END
C
      INTEGER FUNCTION NUMLES(ALF,BET2,ZETA,N,INC,EPS)
C
C.... ROUTINE TO PERFORM THE SPECTRUM SLICING OF A TRIDIAGONAL MATRIX.
C
C     IF INC =  1, NUMLES RETURNS THE NUMBER OF EIGENVALUES BELOW ZETA.
C     IF INC = -1, NUMLES RETURNS THE NUMBER OF EIGENVALUES ABOVE ZETA.
C
C.... INPUTS
C
C     ALF(N)   DIAGONALS OF T
C     BET2(N)  SQUARE OF THE OFF-DIAGONALS OF T
C     ZETA     THE SHIFT TO BE APPLIED TO T
C     N        DIMENSION OF THE TRIDIAGONAL MATRIX
C     INC      INDEX TO INDICATE ABOVE OR BELOW
C     EPS      COMPUTER PRECISION
C
C.... OUTPUTS
C
C     NUMLES   THE NUMBER OF EIGENVALUES ABOVE/BELOW ZETA.
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION ALF(*),BET2(*)
C
      COMMON /LANCON/ ZERO, TENTH, EIGHTH, FOURTH, HALF, ONE, TWO,
     1                FOUR, TEN, ONE28, TWO56, FIVE12, ORTFAC, OVRFLW
C
      SAVE = BET2(1)
      BET2(1) = ZERO
      DEL = ONE
      K = 0
      DO 10 J=1,N
         DEL = (ALF(J) - ZETA) - BET2(J)/DEL
C        IF ( DEL .EQ. ZERO ) DEL = EPS*BET2(J+1)*INC
         IF (DABS( DEL - ZERO).LT.1.0D-30 ) DEL = EPS*BET2(J+1)*INC
         IF ( DEL .LT. ZERO ) K = K + 1
10    CONTINUE
C
      NUMLES = K
      IF ( INC .LT. 0 ) NUMLES = N - K
      BET2(1) = SAVE
C
      RETURN
      END
C
      SUBROUTINE QLBOT(ALF,BET2,THET,BOT,J)
C
C.... COMPUTE THE BOTTOM ELEMENT OF THE NORMALIZED EIGENVECTOR OF A
C     TRIDIAGONAL MATRIX CORRESPONDING TO EIGENVALUE THET.
C
C.... INPUTS
C
C     ALF(J)   DIAGONALS OF T
C     BET2(J)  SQUARE OF THE OFF-DIAGONALS OF T
C     THET     EIGENVALUE OF T
C     J        DIMENSION OF THE TRIDIAGONAL MATRIX
C
C.... OUTPUTS
C
C     BOT      BOTTOM ELEMENT OF THE NORMALIZED EIGENVECTOR
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION ALF(*),BET2(*)
C
      COMMON /LANCON/ ZERO, TENTH, EIGHTH, FOURTH, HALF, ONE, TWO,
     1                FOUR, TEN, ONE28, TWO56, FIVE12, ORTFAC, OVRFLW
C
      BOT = ONE
      C = ONE
      S = ZERO
      G = ALF(J) - THET
      P = G**2
C
      DO 100 I=J-1,1,-1
         B = BET2(I+1)
         R = P + B
         OLDC = C
         C = P/R
         S = B/R
         OLDG = G
         A = ALF(I)
         G = C*(A - THET) - S*OLDG
C        IF ( C .EQ. ZERO ) THEN
         IF (DABS( C - ZERO).LT.1.0D-30 ) THEN
            P = OLDC*B
         ELSE
            P = G**2/C
         END IF
         BOT = BOT*S
100   CONTINUE
C
      RETURN
      END
C
      SUBROUTINE MOVE1(Y,K,L,MINC,T)
C
C.... MOVES THE CONTENT OF Y TO OPEN A SPACE FOR T.
C
C.... INPUT/OUTPUT
C
C     Y     THE ARRAY TO BE REORGANIZED
C     K     THE POSITION IN Y OF THE NEW ELEMENT T
C     L     END OF DATA IN Y
C     MINC  THE INCREMENT +1 OR -1
C     T     THE NEW ELEMENT TO BE INSERTED
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION Y(1)
C
C     IF(MINC.EQ.1) L=1
      DO 100 I=L,K-MINC,MINC
         Y(I) = Y(I+MINC)
100   CONTINUE
      Y(K) = T
C
      RETURN
      END
C=======================================================================
      SUBROUTINE ALDLT(A,MAXA,NN)
CM      SUBROUTINE ALDLT(NN)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
CE------- RESEN FOR ONE PART SYSTEM -------------
CS------- RESEN ZA JEDNODELNI SITEM -------------
C
CM      COMMON A(10000),B(10000),MAXA(212)
C     COMMON /RSN   / DETER,IPIVOT,IDETER
C     COMMON /ECLANM/ AMAXK,AMINK,AMAXF,AMINF
C     COMMON /CDEBUG/ IDEBUG
C     COMMON /SRPSKI/ ISRPS
      DIMENSION A(*),MAXA(*)
C
C      IF(IDEBUG.GT.0) PRINT *, ' ALDLT'
      DO 140 N=1,NN
        KN=MAXA(N)
        KL=KN+1
        KU=MAXA(N+1)-1
        KH=KU-KL
C
      IF(KH)110,90,50
  50    K=N-KH
        IC=0
        KLT=KU
        DO 80 J=1,KH
        IC=IC+1
        KLT=KLT-1
        KI=MAXA(K)
        ND=MAXA(K+1)-KI-1
        IF(ND)80,80,60
  60    KK=MIN0(IC,ND)
        C=0.
        DO 70 L=1,KK
  70    C=C+A(KI+L)*A(KLT+L)
        A(KLT)=A(KLT)-C
  80    K=K+1
  90    K=N
        BB=0.
        DO 100 KK=KL,KU
        K=K-1
        KI=MAXA(K)
        C=A(KK)/A(KI)
        BB=BB+C*A(KK)
 100    A(KK)=C
        A(KN)=A(KN)-BB
C
 110  IF(A(KN))120,120,140
 120  WRITE(3,2000)N,A(KN)
        STOP
 140   CONTINUE
       RETURN
2000  FORMAT(' MATRICA NIJE POZITVNO DEFINITNA ZA JEDNACINU',I4/
     1'   PIVOT =',E20.12)
       END
C=======================================================================
      SUBROUTINE OPK(A,MAXA,U,V,NN)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
CE------- RESEN FOR ONE PART SYSTEM -------------
CS------- RESEN ZA JEDNODELNI SITEM -------------
C
CM      COMMON A(10000),B(10000),MAXA(212)
C     COMMON /RSN   / DETER,IPIVOT,IDETER
C     COMMON /ECLANM/ AMAXK,AMINK,AMAXF,AMINF
C     COMMON /CDEBUG/ IDEBUG
C     COMMON /SRPSKI/ ISRPS
      DIMENSION A(*),MAXA(*)
      DIMENSION U(*),V(*)
C
C      IF(IDEBUG.GT.0) PRINT *, ' OPK'
      DO 1 I=1,NN
1     V(I)=U(I)
CE     REDUCE  FREE  VECTOR
CS     REDUKOVANJE SLOBODNOG VEKTORA
        DO 180 N=1,NN
        KL=MAXA(N)+1
        KU=MAXA(N+1)-1
        IF(KU-KL)180,160,160
 160    K=N
        C=0.
        DO 170 KK=KL,KU
        K=K-1
 170    C=C+A(KK)*V(K)
        V(N)=V(N)-C
 180    CONTINUE
C       ZAMENA UNAZAD
        DO 200 N=1,NN
        K=MAXA(N)
 200    V(N)=V(N)/A(K)
        IF(NN.EQ.1)RETURN
        N=NN
        DO 230 L=2,NN
        KL=MAXA(N)+1
        KU=MAXA(N+1)-1
        IF(KU-KL)230,210,210
 210    K=N
        DO 220 KK=KL,KU
        K=K-1
 220    V(K)=V(K)-A(KK)*V(N)
 230    N=N-1
        RETURN
        END
C=======================================================================
C
C=======================================================================
      SUBROUTINE OPM(B,MAXA,RR,TT,NN)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
C ......................................................................
C .
CE.  P R O G R A M
CE.     TO MULTIPLY MATRIX STORED BY COLUMNS AND VECTOR
CS.   P R O G R A M
CS.      ZA MNOZENJE MATRICE SLOZENE PO STUPCIMA I VEKTORA
C .
CE.       B - MATRIX STORE BY COLUMNS
CE.       RR- VECTOR
CE.       TT= TT+B*RR
CE.    MAXA - ADDRESSES OF DIAGONAL ELEMENTS IN MATRIX b
CE.      NN - NUMBER OF ROW IN B, ALSO NUMBER OF MEMBERS IN VECTORS RR
CE.           AND TT
CS.       B - MATRICA UREDJENA PO STUPCIMA
CS.       RR- VEKTOR KOJI SE MNOZI MATRICOM
CS.       TT- PROIZVOD TT=TT+B*RR
CS.    MAXA - VEKTOR ADRESA DIJAGONALNIH CLANOVA MATRICE B (DIMENZ.NN+1)
CS.      NN - BROJ VRSTA U MATRICI B, TJ. CLANOVA U VEKTORIMA RR I TT
C .
C ......................................................................
C
CM      COMMON A(10000),B(10000),MAXA(212)
C     COMMON /CDEBUG/ IDEBUG
      DIMENSION RR(*),TT(*)
      DIMENSION B(*),MAXA(*)
C
      DO 40 I=1,NN
   40 TT(I)=0.
      DO 100 I=1,NN
      KL=MAXA(I)
      KU=MAXA(I+1) - 1
      II=I + 1
      CC=RR(I)
      DO 100 KK=KL,KU
      II=II - 1
  100 TT(II)=TT(II) + B(KK)*CC
      DO 200 I=2,NN
      KL=MAXA(I) + 1
      KU=MAXA(I+1) - 1
      IF (KU-KL) 200,210,210
  210 II=I
      AA=0.
      DO 220 KK=KL,KU
      II=II - 1
  220 AA=AA + B(KK)*RR(II)
      TT(I)=TT(I) + AA
  200 CONTINUE
C
      RETURN
      END
C
      SUBROUTINE STORE(V,N,J,ISW)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION V(N)
      IF(ISW.LT.1.OR.ISW.GT.2) RETURN
      GO TO (10,20),ISW
10    WRITE(UNIT=29,REC=J,ERR=99) V
      RETURN
20    READ(UNIT=29,REC=J,ERR=99) V
99    RETURN
      END
C
      FUNCTION IDAMAXPAK (N,A,N1)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(N)
      AMAX=DABS(A(1))
      IDAMAXPAK=1
      DO 100 I=2,N
      IF(DABS(A(I)).GT.AMAX) THEN
      AMAX=DABS(A(I))
      IDAMAXPAK=I
      ENDIF
 100  CONTINUE
      RETURN
      END
      SUBROUTINE DAXPYPAK(N,AKON,X,M1,Y,N1)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION X(N),Y(N)
      DO 100 I=1,N
      Y(I)=Y(I)+AKON*X(I)
100   CONTINUE
      RETURN
      END
      SUBROUTINE DCOPYPAK(N,X,N1,Y,M1)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION X(N),Y(N)
      DO 100 I=1,N
      Y(I)=X(I)
100   CONTINUE
      RETURN
      END
      FUNCTION DDOTPAK(N,A,MA,B,MB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(N),B(N)
      DDOTPAK=0.D0
      DO 100 I=1,N
      DDOTPAK=DDOTPAK+A(I)*B(I)
100   CONTINUE
      RETURN
      END
      SUBROUTINE DSCALPAK(N,AKON,A,N1)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(N)
      DO 100 I=1,N
      A(I)=A(I)*AKON
100   CONTINUE
      RETURN
      END
      SUBROUTINE DZERO(N,A,N1)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(N)
      DO 100 I=1,N
      A(I)=0.0D0
100   CONTINUE
      RETURN
      END
